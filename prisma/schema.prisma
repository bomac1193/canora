// CANORA - Cultural Decision System
// Prisma Schema for Institutional Music Archive

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// ENUMS
// ============================================

enum Role {
  VIEWER    // Can view Canon Archive, Curated Lists, Work pages
  CREATOR   // Can create Works (JAM), add Contributions, create forks
  CURATOR   // Can promote JAM→PLATE→CANON, create Curated Lists
  ADMIN     // Can manage roles
}

enum WorkStatus {
  JAM       // Initial state - raw, unreviewed
  PLATE     // Elevated - curator reviewed, notable
  CANON     // Permanent - irreversibly canonized
}

enum EdgeType {
  FORK      // Direct fork/remix of parent
  MERGE     // Combination of multiple parents
  DERIVED   // Loosely inspired by/derived from
}

enum ContributionRole {
  VOCAL     // Vocals, singing, spoken word
  BEAT      // Drums, percussion, rhythm programming
  LYRIC     // Lyrics, written word
  SOUND     // Sound design, synthesis, production
  CURATION  // Curatorial contribution (selection, sequencing)
  AI_ASSIST // AI-assisted generation (must be disclosed)
}

// ============================================
// AUTH MODELS (NextAuth compatible)
// ============================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// USER MODEL
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  role          Role      @default(VIEWER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // NextAuth relations
  accounts Account[]
  sessions Session[]

  // CHORA relations
  contributions    Contribution[]
  promotionEvents  PromotionEvent[]   @relation("SignedBy")
  curatedLists     CuratedList[]
  canonLockedWorks Work[]             @relation("CanonLockedBy")
  createdWorks     Work[]             @relation("CreatedBy")

  // API & Webhook relations
  apiKeys              ApiKey[]
  webhookSubscriptions WebhookSubscription[]
}

// ============================================
// CORE DOMAIN MODELS
// ============================================

model Work {
  id          String     @id @default(cuid())
  slug        String     @unique // Human-readable slug (e.g., "midnight-echoes-a3b2")
  title       String
  description String?    @db.Text
  status      WorkStatus @default(JAM)
  audioUrl    String?    // S3 URL for audio file
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Canon lock fields - once CANON, these are set and work cannot change
  canonLockedAt       DateTime?
  canonLockedByUserId String?
  canonLockedBy       User?     @relation("CanonLockedBy", fields: [canonLockedByUserId], references: [id])

  // Creator tracking
  createdByUserId String?
  createdBy       User?   @relation("CreatedBy", fields: [createdByUserId], references: [id])

  // Relations
  contributions   Contribution[]
  promotionEvents PromotionEvent[]
  curatedListItems CuratedListItem[]

  // Lineage relations (many-to-many via WorkEdge)
  parentEdges  WorkEdge[] @relation("ToWork")   // Edges pointing TO this work (parents)
  childEdges   WorkEdge[] @relation("FromWork") // Edges pointing FROM this work (children)

  // Discovery & signals (SELECTR integration)
  discoverySignal DiscoverySignal?
  selectrSignals  SelectrSignal[]
  audioAnalysis   AudioAnalysis?

  // CTAD metadata (Creative Track Attribution Data)
  ctadId       String? @unique // Universal CTAD identifier
  ctadMetadata Json?           // Full CTAD schema

  // O8 Provenance (AI generation proof)
  o8Provenance O8Provenance?

  // ISSUANCE integration
  issuanceId          String?
  issuanceFingerprint String?

  @@index([status])
  @@index([createdAt])
  @@index([canonLockedAt])
  @@index([ctadId])
}

model WorkEdge {
  id        String   @id @default(cuid())
  type      EdgeType
  createdAt DateTime @default(now())

  // From work -> To work (fromWork is parent, toWork is child)
  fromWorkId String
  fromWork   Work   @relation("FromWork", fields: [fromWorkId], references: [id], onDelete: Cascade)

  toWorkId String
  toWork   Work   @relation("ToWork", fields: [toWorkId], references: [id], onDelete: Cascade)

  @@unique([fromWorkId, toWorkId])
  @@index([fromWorkId])
  @@index([toWorkId])
}

model Contribution {
  id          String           @id @default(cuid())
  role        ContributionRole
  displayName String           // Visible credit name
  notes       String?          @db.Text
  createdAt   DateTime         @default(now())

  // Work relation
  workId String
  work   Work   @relation(fields: [workId], references: [id], onDelete: Cascade)

  // User relation (nullable - allows crediting non-users)
  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  @@index([workId])
  @@index([userId])
}

model PromotionEvent {
  id            String     @id @default(cuid())
  fromStatus    WorkStatus
  toStatus      WorkStatus
  justification String     @db.Text // Required - why this work deserves promotion
  createdAt     DateTime   @default(now())

  // Work being promoted
  workId String
  work   Work   @relation(fields: [workId], references: [id], onDelete: Cascade)

  // Curator who signed the promotion (required - no anonymous promotions)
  signedByUserId      String
  signedByDisplayName String // Captured at time of signing
  signedBy            User   @relation("SignedBy", fields: [signedByUserId], references: [id])

  @@index([workId])
  @@index([signedByUserId])
  @@index([createdAt])
}

// ============================================
// CURATED LISTS
// ============================================

model CuratedList {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Curator who created the list
  curatorUserId String
  curator       User   @relation(fields: [curatorUserId], references: [id])

  // Items in the list
  items CuratedListItem[]

  @@index([curatorUserId])
}

model CuratedListItem {
  id         String   @id @default(cuid())
  orderIndex Int      // For manual ordering
  createdAt  DateTime @default(now())

  // List relation
  listId String
  list   CuratedList @relation(fields: [listId], references: [id], onDelete: Cascade)

  // Work relation
  workId String
  work   Work   @relation(fields: [workId], references: [id], onDelete: Cascade)

  @@unique([listId, workId])
  @@index([listId])
  @@index([workId])
}

// ============================================
// API KEY MANAGEMENT
// ============================================

model ApiKey {
  id        String    @id @default(cuid())
  name      String
  key       String    @unique
  hashedKey String
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  scopes    String[]
  lastUsedAt DateTime?
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())

  @@index([key])
  @@index([userId])
}

// ============================================
// WEBHOOK SUBSCRIPTIONS
// ============================================

model WebhookSubscription {
  id        String   @id @default(cuid())
  url       String
  events    String[]
  secret    String
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  active    Boolean  @default(true)
  failures  Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([active])
}

// ============================================
// DISCOVERY SIGNALS (Etherfeed Integration)
// ============================================

model DiscoverySignal {
  id           String   @id @default(cuid())
  workId       String   @unique
  work         Work     @relation(fields: [workId], references: [id], onDelete: Cascade)

  // Scoring (0-1 normalized)
  shadowScore  Float    @default(0.5)  // Higher = rarer/underground
  noveltyScore Float    @default(0.5)  // Higher = more unique/experimental
  decayScore   Float    @default(0.5)  // Recency decay factor

  // Engagement metrics (from SELECTR)
  playCount    Int      @default(0)
  voteCount    Int      @default(0)
  battleCount  Int      @default(0)
  winCount     Int      @default(0)
  dropCount    Int      @default(0)   // Times dropped by curators

  // Audio embedding (512 dims from Etherfeed)
  // Use raw SQL for pgvector similarity: SELECT * FROM ... ORDER BY embedding <-> $1
  embedding    Float[]

  // Emotion axes (Etherfeed 6-axis model)
  ecstatic     Float?   // 0-1
  yearning     Float?   // 0-1
  corrupted    Float?   // 0-1
  lucid        Float?   // 0-1
  divine       Float?   // 0-1
  feral        Float?   // 0-1

  // Audio features (from Etherfeed Essentia analysis)
  bpm          Float?
  key          String?              // e.g., "C major", "A minor"
  energy       Float?               // 0-1
  valence      Float?               // 0-1 (musical positiveness)
  danceability Float?               // 0-1

  // UMAP coordinates for vibe map visualization
  umapX        Float?
  umapY        Float?

  // Analysis metadata
  analysisSource  String?           // "etherfeed", "manual", "import"
  analysisVersion String?           // Version of Etherfeed used
  computedAt      DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([shadowScore])
  @@index([noveltyScore])
  @@index([voteCount])
  @@index([bpm])
}

// ============================================
// SELECTR SIGNALS (Game Layer Integration)
// ============================================

model SelectrSignal {
  id         String   @id @default(cuid())
  workId     String
  work       Work     @relation(fields: [workId], references: [id], onDelete: Cascade)

  source     String   @default("selectr")
  signalType String   // "vote", "drop", "battle_win", "battle_loss", "mission_complete"
  userId     String?  // SELECTR user ID (may not map to CANORA user)
  metadata   Json?    // Additional signal data

  createdAt  DateTime @default(now())

  @@index([workId])
  @@index([signalType])
  @@index([createdAt])
}

// ============================================
// AUDIO ANALYSIS (Full Etherfeed Results)
// ============================================

model AudioAnalysis {
  id           String   @id @default(cuid())
  workId       String   @unique
  work         Work     @relation(fields: [workId], references: [id], onDelete: Cascade)

  // Source file info
  audioUrl     String
  audioHash    String?              // SHA256 of audio file for deduplication
  duration     Float?               // Seconds
  sampleRate   Int?
  channels     Int?

  // Full Etherfeed analysis (JSON blob)
  // Includes: spectral features, rhythm, tonal, loudness, timbre, high-level
  essentia     Json?

  // Raw embedding (may be larger than what we store in DiscoverySignal)
  fullEmbedding Float[]

  // Processing metadata
  status       String   @default("pending")  // pending, processing, completed, failed
  error        String?
  processingMs Int?                 // How long analysis took
  etherfeedVersion String?

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([status])
  @@index([audioHash])
}

// ============================================
// ANALYSIS QUEUE (Etherfeed Job Tracking)
// ============================================

model AnalysisJob {
  id           String   @id @default(cuid())
  workId       String
  audioUrl     String

  // Job status
  status       String   @default("queued")  // queued, processing, completed, failed
  priority     Int      @default(0)         // Higher = process first
  attempts     Int      @default(0)
  maxAttempts  Int      @default(3)
  error        String?

  // Etherfeed response
  etherfeedJobId String?             // Job ID from Etherfeed service
  result       Json?                 // Full response from Etherfeed

  // Timing
  queuedAt     DateTime @default(now())
  startedAt    DateTime?
  completedAt  DateTime?

  @@index([status, priority])
  @@index([workId])
}

// ============================================
// O8 PROVENANCE (AI Generation Proof)
// ============================================

model O8Provenance {
  id                  String   @id @default(cuid())
  workId              String   @unique
  work                Work     @relation(fields: [workId], references: [id], onDelete: Cascade)

  // Generation details
  platform            String   // "suno", "udio", "other"
  platformVersion     String?
  generatedAt         DateTime
  prompt              String   @db.Text
  negativePrompt      String?  @db.Text
  parameters          Json?    // model, seed, duration, style, etc.

  // Output info captured at generation
  originalAudioUrl    String?
  originalTitle       String?

  // Creator identity
  creatorPlatformId   String   // User ID on Suno/Udio
  creatorPlatformName String?

  // Cryptographic verification
  signatureAlgorithm  String   @default("ed25519")
  publicKey           String
  signature           String   @db.Text
  signedAt            DateTime

  // Verification status
  verified            Boolean  @default(false)
  verifiedAt          DateTime?
  verificationError   String?

  createdAt           DateTime @default(now())

  @@index([platform])
  @@index([generatedAt])
  @@index([verified])
}
